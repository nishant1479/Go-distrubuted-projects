package main

import (
	"encoding/json"
	"net/http"
	"strconv"

	_ "books-api/docs" // generated by swag
	httpSwagger "github.com/swaggo/http-swagger"
)

// Book model
type Book struct {
	ID     int    `json:"id"`
	Title  string `json:"title"`
	Author string `json:"author"`
}

var books = []Book{
	{ID: 1, Title: "Go Basics", Author: "Alice"},
	{ID: 2, Title: "Advanced Go", Author: "Bob"},
}

// @title Books API
// @version 1.0
// @description A simple CRUD API for managing books.
// @host localhost:8081
// @BasePath /
func main() {
	http.HandleFunc("/books", booksHandler)       // GET all, POST new
	http.HandleFunc("/books/", bookByIDHandler)   // GET, PUT, DELETE by ID
	http.Handle("/swagger/", httpSwagger.WrapHandler)

	http.ListenAndServe(":8081", nil)
}

// @Summary Get all books
// @Description Returns list of all books
// @Produce json
// @Success 200 {array} Book
// @Router /books [get]
func getBooks(w http.ResponseWriter, r *http.Request) {
	json.NewEncoder(w).Encode(books)
}

// @Summary Create a new book
// @Description Adds a book to the list
// @Accept json
// @Produce json
// @Param book body Book true "New Book"
// @Success 201 {object} Book
// @Router /books [post]
func createBook(w http.ResponseWriter, r *http.Request) {
	var newBook Book
	_ = json.NewDecoder(r.Body).Decode(&newBook)
	newBook.ID = len(books) + 1
	books = append(books, newBook)
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(newBook)
}

func booksHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		getBooks(w, r)
	case http.MethodPost:
		createBook(w, r)
	}
}

// @Summary Get a book by ID
// @Description Returns a single book
// @Param id path int true "Book ID"
// @Produce json
// @Success 200 {object} Book
// @Failure 404 {string} string "Book not found"
// @Router /books/{id} [get]
func getBookByID(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Path[len("/books/"):]
	id, _ := strconv.Atoi(idStr)
	for _, book := range books {
		if book.ID == id {
			json.NewEncoder(w).Encode(book)
			return
		}
	}
	http.NotFound(w, r)
}

// @Summary Update a book
// @Description Updates an existing book by ID
// @Param id path int true "Book ID"
// @Param book body Book true "Updated Book"
// @Produce json
// @Success 200 {object} Book
// @Failure 404 {string} string "Book not found"
// @Router /books/{id} [put]
func updateBook(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Path[len("/books/"):]
	id, _ := strconv.Atoi(idStr)
	var updated Book
	_ = json.NewDecoder(r.Body).Decode(&updated)
	for i, book := range books {
		if book.ID == id {
			books[i].Title = updated.Title
			books[i].Author = updated.Author
			json.NewEncoder(w).Encode(books[i])
			return
		}
	}
	http.NotFound(w, r)
}

// @Summary Delete a book
// @Description Deletes a book by ID
// @Param id path int true "Book ID"
// @Success 204 {string} string "No Content"
// @Failure 404 {string} string "Book not found"
// @Router /books/{id} [delete]
func deleteBook(w http.ResponseWriter, r *http.Request) {
	idStr := r.URL.Path[len("/books/"):]
	id, _ := strconv.Atoi(idStr)
	for i, book := range books {
		if book.ID == id {
			books = append(books[:i], books[i+1:]...)
			w.WriteHeader(http.StatusNoContent)
			return
		}
	}
	http.NotFound(w, r)
}

func bookByIDHandler(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case http.MethodGet:
		getBookByID(w, r)
	case http.MethodPut:
		updateBook(w, r)
	case http.MethodDelete:
		deleteBook(w, r)
	}
}
